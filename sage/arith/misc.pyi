u"""
Python interface for the `sage.arith.misc` module.

http://doc.sagemath.org/html/en/reference/rings_standard/sage/arith/misc.html
"""

from typing import Any, List, Optional, Union

from sage.rings.integer import Integer



class Euler_Phi(object):
    def __init__(self, n:int) -> None: ...
    def plot(self, xmin=1, xmax=50, pointsize=30, rgbcolor=(0, 0, 1), join=True, **kwds): ...


class Moebius(object):
    def __init__(self, n): ...
    def plot(self, xmin=0, xmax=50, pointsize=30, rgbcolor=(0, 0, 1), join=True, **kwds): ...
    def range(self, start, stop=None, step=None): ...

class Sigma(object):
    def __init__(self, n, k = 1) -> None: ...
    def plot(xmin=1, xmax=50, k=1, pointsize=30, rgbcolor=(0, 0, 1), join=True, **kwds): ...

def CRT(a, b, m=None, n=None): ...
def CRT_basis(moduli): ...
def CRT_list(v, moduli): ...
def CRT_vectors(X, moduli): ...
def GCD(a: Union[Integer, List[Integer]], b: Optional[Integer] = None, **kwargs: Any) -> Integer: ...
def LCM(a, b=None): ...
def XGCD(a, b): ...

def algdep(
    z,
    degree,
    known_bits=None,
    use_bits=None,
    known_digits=None,
    use_digits=None,
    height_bound=None,
    proof=False
): ...

def algebraic_dependency(
    z,
    degree,
    known_bits=None,
    use_bits=None,
    known_digits=None,
    use_digits=None,
    height_bound=None,
    proof=False
): ...

def bernoulli(n, algorithm='default', num_threads=1): ...
def binomial(x, m, **kwds): ...
def binomial_coefficients(n): ...
def continuant(v, n=None): ...
def crt(a, b, m=None, n=None): ...
def dedekind_sum(p, q, algorithm='default'): ...
def differences(lis, n=1): ...
def divisors(n): ...
def eratosthenes(n): ...
def factor(n, proof=None, int_=False, algorithm='pari', verbose=0, **kwds): ...
def factorial(n, algorithm='gmp'): ...
def falling_factorial(x, a): ...
def four_squares(n): ...
def fundamental_discriminant(D): ...
def gcd(a, b=None, **kwargs): ...
def get_gcd(order): ...
def get_inverse_mod(order): ...
def hilbert_conductor(a, b): ...
def hilbert_conductor_inverse(d): ...
def hilbert_symbol(a, b, p, algorithm='pari'): ...
def integer_ceil(x): ...
def integer_floor(x): ...
def inverse_mod(a, m): ...
def is_power_of_two(n): ...
def is_prime(n): ...
def is_prime_power(n, flag=None, get_data=False): ...
def is_pseudoprime(n, flag=None): ...
def is_pseudoprime_power(n, get_data=False): ...
def is_pseudoprime_small_power(n, bound=None, get_data=False): ...
def is_square(n, root=False): ...
def is_squarefree(n): ...
def jacobi_symbol(a, b): ...
def kronecker(x, y): ...
def kronecker_symbol(x, y): ...
def lcm(a, b=None): ...
def legendre_symbol(x, p): ...
def mqrr_rational_reconstruction(u, m, T): ...
def multinomial(*ks): ...
def multinomial_coefficients(m, n): ...
def next_prime(n, proof=None): ...
def next_prime_power(n): ...
def next_probable_prime(n): ...
def nth_prime(n): ...
def number_of_divisors(n): ...
def odd_part(n): ...
def power_mod(a, n, m): ...
def previous_prime(n): ...
def previous_prime_power(n): ...
def prime_divisors(n): ...
def prime_factors(n): ...
def prime_powers(start, stop=None): ...
def prime_to_m_part(n, m): ...
def primes(start, stop=None, proof=None): ...
def primes_first_n(n, leave_pari=False): ...
def primitive_root(n, check=True): ...
def quadratic_residues(n): ...
def radical(n, *args, **kwds): ...
def random_prime(n, proof=None, lbound=2): ...
def rational_reconstruction(a, m, algorithm='fast'): ...
def rising_factorial(x, a): ...
def sort_complex_numbers_for_display(nums): ...
def squarefree_divisors(x): ...
def subfactorial(n): ...
def sum_of_k_squares(k, n): ...
def three_squares(n): ...
def trial_division(n, bound=None): ...
def two_squares(n): ...
def valuation(m, *args, **kwds): ...
def xgcd(a, b): ...
def xkcd(n=''): ...
def xlcm(m, n): ...
