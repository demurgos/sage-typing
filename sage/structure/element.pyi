u"""
Python interface for the `sage.structure.element` module.

http://doc.sagemath.org/html/en/reference/structure/sage/structure/element.html
"""

from typing import Any, List, Mapping, Tuple

import sage.structure.sage_object


class Element(sage.structure.sage_object.SageObject):
    def _cmp_(self, left: Any, right: Any) -> Any: ...
    def _richcmp_(self, left: Any, right: Any, op: Any) -> Any: ...
    def N(self, prec: Any = None, digits: Any = None, algorithm: Any = None) -> Any: ...
    def base_extend(self, R:Any) -> Any: ...
    def base_ring(self) -> Any: ...
    def category(self) -> Any: ...
    def is_zero(self) -> bool: ...
    def n(self, prec: Any = None, digits: Any = None, algorithm: Any = None) -> Any: ...
    def numerical_approx(self,
                         prec: Any = None,
                         digits: Any = None,
                         algorithm: Any = None
                         ) -> Any: ...
    def parent(self, x: type = None) -> Any: ...
    def subs(self, in_dict: Mapping = None, **kwds: Any) -> Any: ...
    def substitute(self, in_dict: Mapping = None, **kwds: Any) -> Any: ...


class ModuleElement(Element):
    def  additive_order(self) -> Any: ...
    def  order(self) -> Any: ...


class RingElement(ModuleElement):
    def abs(self) -> Any: ...
    def additive_order(self): ...
    def is_nilpotent(self): ...
    def is_one(self): ...
    def is_prime(self): ...
    def multiplicative_order(self): ...
    def powers(self, n: int) -> List[Any]: ...


class CommutativeRingElement(RingElement):
    def divides(self, x: Any) -> bool: ...
    def inverse_mod(self, I) -> Any: ...
    def is_square(self, root: bool = False) -> Any: ...
    def mod(self, I): ...
    def sqrt(self, extend: bool = True, all: bool = False, name: str = None) -> Any: ...


class IntegralDomainElement(CommutativeRingElement):
    def is_nilpotent(self) -> Any: ...


class DedekindDomainElement(IntegralDomainElement):
    pass


class PrincipalIdealDomainElement(DedekindDomainElement):
    def lcm(self, right) -> Any: ...


class EuclideanDomainElement(PrincipalIdealDomainElement):
    def degree(self): ...
    def leading_coefficient(self): ...
    def quo_rem(self, other): ...


class FieldElement(CommutativeRingElement):
    def divides(self, other) -> bool: ...
    def is_unit(self) -> bool: ...
    def quo_rem(self, right) -> Tuple: ...


class InfinityElement(RingElement):
    pass


class Matrix(ModuleElement):
    pass


class AdditiveGroupElement(ModuleElement):
    def order(self) -> Any: ...


class Vector(ModuleElement):
    pass


class MonoidElement(Element):
    def multiplicative_order(self) -> Any: ...
    def order(self) -> Any: ...
    def powers(self, n) -> Any: ...


class MultiplicativeGroupElement(MonoidElement):
    def order(self) -> Any: ...


class ElementWithCachedMethod(Element):
    pass


coerce_binop = ...

def bin_op(x, y, op) -> Any: ...
def canonical_coercion(x, y) -> Any: ...
def coerce_cmp(x, y) -> Any: ...
def coercion_traceback(dump=True) -> Any: ...
def generic_power(a, n, one=None) -> Any: ...
def get_coercion_model() -> Any: ...
def have_same_parent(left, right) -> Any: ...
def is_AdditiveGroupElement(x) -> bool: ...
def is_AlgebraElement(x) -> bool: ...
def is_CommutativeAlgebraElement(x) -> bool: ...
def is_CommutativeRingElement(x) -> bool: ...
def is_DedekindDomainElement(x) -> bool: ...
def is_Element(x) -> bool: ...
def is_EuclideanDomainElement(x) -> bool: ...
def is_FieldElement(x) -> bool: ...
def is_InfinityElement(x) -> bool: ...
def is_IntegralDomainElement(x) -> bool: ...
def is_Matrix(x) -> bool: ...
def is_ModuleElement(x) -> bool: ...
def is_MonoidElement(x) -> bool: ...
def is_MultiplicativeGroupElement(x) -> bool: ...
def is_PrincipalIdealDomainElement(x) -> bool: ...
def is_RingElement(x) -> bool: ...
def is_Vector(x) -> bool: ...
def make_element(_class, _dict, parent) -> Any: ...
def parent(x) -> Any: ...
def set_coercion_model(cm) -> Any: ...
