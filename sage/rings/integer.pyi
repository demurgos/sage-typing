# -*- coding: utf8 -*-
u"""
Python interface for the `sage.rings.integer` module.

Documentation:
http://doc.sagemath.org/html/en/reference/rings_standard/sage/rings/integer.html

Source:
https://github.com/sagemath/sage/blob/master/src/sage/rings/integer.pxd
https://github.com/sagemath/sage/blob/master/src/sage/rings/integer.pyx
"""


from typing import Any, List, Union

import sage.structure.element
import sage.rings.rational

class Integer(sage.structure.element.EuclideanDomainElement):
    def __init__(self, x: Union[int, long, str], base: int = 0) -> None: ...
    def __eq__(self, other: Union[int, long, str, 'Integer']) -> bool: ...

    def __add__(self, other: Union[int, long, str, 'Integer']) -> 'Integer': ...
    def __radd__(self, other: Union[int, long, str, 'Integer']) -> 'Integer': ...
    def __iadd__(self, other: Union[int, long, str, 'Integer']) -> 'Integer': ...

    def __sub__(self, other: Union[int, long, str, 'Integer']) -> 'Integer': ...

    def __mul__(self, other: Union[int, long, str, 'Integer']) -> 'Integer': ...
    def __rmul__(self, other: Union[int, long, str, 'Integer']) -> 'Integer': ...
    def __imul__(self, other: Union[int, long, str, 'Integer']) -> 'Integer': ...

    def __div__(self, other: Union[int, long, str, 'Integer']) -> sage.rings.rational.Rational: ...

    def __floordiv__(self, other: Union[int, long, str, 'Integer']) -> 'Integer': ...


    def __neg__(self) -> 'Integer': ...
    def __pow__(self,
                power: Union[int, long, str, 'Integer'],
                modulo: Union[int, long, str, 'Integer'] = None
                ) -> 'Integer': ...
    def additive_order(self) -> Any: ...
    def binary(self) -> str: ...
    def binomial(self, m: Any, algorithm: str = b'mpir') -> Any: ...
    def bits(self) -> List[Any]: ...
    def ceil(self) -> Any: ...
    def class_number(self, proof: bool = True) -> Any: ...
    def conjugate(self) -> Any: ...
    def coprime_integers(self, m: Any) -> Any: ...
    def crt(self, y: Any, m: Any, n: Any) -> Any: ...
    def denominator(self) -> Any: ...
    def digits(self, base: int = 10, digits: Any = None, padto: int = 0) -> List[Any]: ...
    def divide_knowing_divisible_by(self, right: Any) -> Any: ...
    def divides(self, n: Any): ...
    def divisors(self, method=None) -> List[Any]: ...
    def euclidean_degree(self) -> Any: ...
    def exact_log(self, m) -> Any: ...
    def exp(self, prec=None) -> Any: ...
    def factor(self, algorithm='pari', proof=None, limit=None, int_=False, verbose=0) -> Any: ...
    def factorial(self) -> Any: ...
    def floor(self) -> Any: ...
    def gamma(self) -> Any: ...
    def gcd(self, n) -> Any: ...
    def global_height(self, prec=None) -> Any: ...
    def imag(self) -> Any: ...
    def inverse_mod(self, n) -> Any: ...
    def inverse_of_unit(self) -> Any: ...
    def is_integer(self) -> Any: ...
    def is_integral(self) -> Any: ...
    def is_irreducible(self) -> Any: ...
    def is_norm(self, K, element=False, proof=True) -> Any: ...
    def is_one(self) -> Any: ...
    def is_perfect_power(self) -> Any: ...
    def is_power_of(self, n) -> Any: ...
    def is_prime(self, proof=None) -> Any: ...
    def is_prime_power(self, flag=None, proof=None, get_data=False) -> Any: ...
    def is_pseudoprime(self) -> Any: ...
    def is_pseudoprime_power(self, get_data=False) -> Any: ...
    def is_square(self) -> bool: ...
    def is_squarefree(self) -> Any: ...
    def is_unit(self) -> Any: ...
    def isqrt(self) -> Any: ...
    def jacobi(self, b) -> Any: ...
    def kronecker(self, b) -> Any: ...
    def list(self) -> Any: ...
    def log(self, m=None, prec=None) -> Any: ...
    def multifactorial(self, k) -> Any: ...
    def multiplicative_order(self) -> Any: ...
    def nbits(self) -> Any: ...
    def ndigits(self, base=10) -> Any: ...
    def next_prime(self, proof=None) -> 'Integer': ...
    def next_prime_power(self, proof=None) -> Any: ...
    def next_probable_prime(self) -> Any: ...
    def nth_root(self, n, truncate_mode=0) -> Any: ...
    def numerator(self) -> Any: ...
    def odd_part(self) -> Any: ...
    def ord(self, p) -> Any: ...
    def ordinal_str(self) -> Any: ...
    def perfect_power(self) -> Any: ...
    def popcount(self) -> Any: ...
    def powermod(self, exp, mod) -> Any: ...
    def powermodm_ui(self, *args, **kwds) -> Any: ...
    def previous_prime(self, proof=None) -> Any: ...
    def previous_prime_power(self, proof=None) -> Any: ...
    def prime_divisors(self) -> Any: ...
    def prime_factors(self) -> Any: ...
    def prime_to_m_part(self, m) -> Any: ...
    def quo_rem(self, other) -> Any: ...
    def radical(self, *args, **kwds) -> Any: ...
    def rational_reconstruction(self, m) -> Any: ...
    def real(self) -> Any: ...
    def sign(self) -> Any: ...
    def sqrt(self) -> Any: ...
    def sqrtrem(self) -> Any: ...
    def squarefree_part(self, bound=-1) -> Any: ...
    def str(self, base=10) -> Any: ...
    def support(self) -> Any: ...
    def test_bit(self, index) -> Any: ...
    def trailing_zero_bits(self) -> Any: ...
    def trial_division(self, bound='LONG_MAX', start=2) -> Any: ...
    def val_unit(self, p) -> Any: ...
    def valuation(self, p) -> Any: ...
    def xgcd(self, n) -> Any: ...


class IntegerWrapper(Integer):
    pass

